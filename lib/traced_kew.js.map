{"version":3,"sources":["../src/traced_kew.js"],"names":[],"mappings":"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","file":"traced_kew.js","sourcesContent":["/* eslint-disable no-use-before-define */\n\nimport * as Q from 'kew';\nimport Tracer from 'opentracing';\n\nfunction _randomGUID() {\n    return [\n        `00000000${Math.abs((Math.random() * 0xFFFFFFFF) | 0).toString(16)}`.substr(-8),\n        `00000000${Math.abs((Math.random() * 0xFFFFFFFF) | 0).toString(16)}`.substr(-8),\n    ].join('');\n}\n\nlet uniqueLinkID = 0;\nfunction _joinKey() {\n    uniqueLinkID++;\n    return `join:linked_trace_${uniqueLinkID}`;\n}\n\nfunction _joinSpans(parent, child) {\n    if (!parent || !child) {\n        return;\n    }\n    const joinKey = _joinKey();\n    const joinValue = _randomGUID();\n    parent.setTag(joinKey, joinValue);\n    child.setTag(joinKey, joinValue);\n}\n\n\nfunction _linkChildren(span, promises) {\n    const spanImp = span.imp();\n    const joinValue = _randomGUID();\n    const joinKey = _joinKey();\n    span.setTag(joinKey, joinValue);\n\n    // Loop through the children and retroactively link them to  span for\n    // the \"all\" operation. Also back date the parent to the oldest child.\n    // This is LightStep-specific.\n    const children = promises;\n    let beginMicros = span.imp().beginMicros();\n    for (let i = 0; i < children.length; i++) {\n        let child = children[i];\n        if (!(child instanceof TracedKew)) {\n            continue;\n        }\n        const childSpan = child.span();\n        if (!childSpan) {\n            continue;\n        }\n        childSpan.setTag(joinKey, joinValue);\n\n        const childBeginMicros = childSpan.imp().beginMicros();\n        beginMicros = Math.min(childBeginMicros, beginMicros);\n    }\n    spanImp.setBeginMicros(beginMicros);\n}\n\nfunction _wrap(prev, result) {\n    if (result instanceof TracedKew) {\n        _joinSpans(prev.span(), result.span());\n        return result;\n    }\n    if (result instanceof Promise) {\n        return new TracedKew({\n            chain   : prev._chain,\n            promise : result,\n        });\n    }\n    return result;\n}\n\n/**\n * Holds a reference \"tail\" span in a chained of linked spans.\n *\n * A linked span in this context is a child span that starts as soon as its\n * parent finishes. This is essentially the \"followsFrom\" relationship defined\n * in OpenTracing being emulated via \"childOf\" relationships (due to incomplete\n * support for \"followsFrom\").\n *\n * The chained spans correspond to the potential chaining of promise calls,\n * as in pseudo-code such as:\n *\n * ```\n * \t\tQ.all([ promise1, promise2 ])\n * \t\t\t.spread((result1, result2) => {\n * \t\t\t\treturn asyncOp1(result1, result2);\n * \t\t\t})\n * \t\t\t.then((result) => {\n * \t\t\t\treturn asyncOp2(result);\n * \t\t\t})\n * \t\t\t.then((result) => {\n * \t\t\t\tfinalProcessing(result);\n * \t\t\t})\n * \t\t\t.finish();\n * ```\n *\n * Note that the finish() call is a TracedKew-specific method that is needed\n * to signal the end of the chained calls (there's no way to infer the end of\n * the chain implicitly).\n *\n */\nclass SpanChain {\n    constructor(span) {\n        this.span = span;\n    }\n}\n\n/**\n * TracedKew mirrors the kew API while also providing a superset of functionality\n * to enable traced promises.\n */\nexport default class TracedKew {\n\n    //------------------------------------------------------------------------//\n    // Constructor\n    //------------------------------------------------------------------------//\n\n    constructor(opts) {\n        opts = opts || {};\n\n        this.promise = this;  // For kew compatibility\n\n        this._promise = opts.promise;\n        this._chain = opts.chain;\n\n        if (!this._promise) {\n            throw new Error('Invalid promise');\n        }\n    }\n\n    //------------------------------------------------------------------------//\n    // Static functions\n    //------------------------------------------------------------------------//\n\n    static all(promises) {\n        const span = Tracer.startSpan('all');\n        let p = Q.all(promises);\n        p.fin(() => {\n            _linkChildren(span, promises);\n            span.finish();\n        });\n        return new TracedKew({\n            chain   : new SpanChain(span),\n            promise : p,\n        });\n    }\n\n    static tracedAll(span, promises) {\n        _linkChildren(span, promises);\n        return new TracedKew({\n            chain   : new SpanChain(span),\n            promise : Q.all(promises),\n        });\n    }\n\n    static bindPromise(f, scope, ...boundArgs) {\n        return function () {\n            let defer = TracedKew.defer();\n            let thisArgs = Array.prototype.slice.call(arguments);\n            try {\n                f.apply(scope, boundArgs.concat(thisArgs, [ defer.makeNodeResolver()]));\n            } catch (e) {\n                defer.reject(e);\n            }\n            return defer;\n        };\n    }\n\n    static defer(...args) {\n        return new TracedKew({ promise : Q.defer(...args) });\n    }\n\n    static tracedDefer(name, parent) {\n        const span = Tracer.startSpan(`${name}`, { childOf : parent });\n        return new TracedKew({\n            chain   : new SpanChain(span),\n            promise : Q.defer(),\n        });\n    }\n\n    static delay(...args) {\n        const span = Tracer.startSpan('delay');\n        return new TracedKew({\n            chain   : new SpanChain(span),\n            promise : Q.delay(...args),\n        });\n    }\n\n    static tracedDelay(name, parent, ...args) {\n        const span = Tracer.startSpan(`${name}`, { childOf : parent });\n        return new TracedKew({\n            chain   : new SpanChain(span),\n            promise : Q.delay(...args),\n        });\n    }\n\n    static fcall() {\n        throw new Error('NOT_YET_IMPLEMENTED');\n    }\n\n    static isPromise() {\n        throw new Error('NOT_YET_IMPLEMENTED');\n    }\n\n    static isPromiseLike() {\n        throw new Error('NOT_YET_IMPLEMENTED');\n    }\n\n    static ncall() {\n        throw new Error('NOT_YET_IMPLEMENTED');\n    }\n\n    static nfcall() {\n        throw new Error('NOT_YET_IMPLEMENTED');\n    }\n\n    static reject(err) {\n        return new TracedKew({ promise : Q.reject(err) });\n    }\n\n    static resolve(value) {\n        return new TracedKew({ promise : Q.resolve(value) });\n    }\n\n    static spread(promises, f) {\n        return TracedKew.resolve(promises).spread(f);\n    }\n\n    static stats() {\n        return this._promise.stats();\n    }\n\n    static allSettled(promises) {\n        return new TracedKew({\n            promise : Q.allSettled(promises),\n        });\n    }\n\n    static getNextTickFunction(...args) {\n        return Q.getNextTickFunction(...args);\n    }\n\n    static setNextTickFunction(...args) {\n        return Q.setNextTickFunction(...args);\n    }\n\n    //------------------------------------------------------------------------//\n    // Instance methods\n    //------------------------------------------------------------------------//\n\n    fail(...args) {\n        args[0] = this._linkSpan('fail', false, true, args[0]);\n        return new TracedKew({\n            chain   : this._chain,\n            promise : this._promise.fail(...args),\n        });\n    }\n\n    tracedFail(...args) {\n        args[0] = this._linkSpan('fail', true, true, args[0]);\n        return new TracedKew({\n            chain   : this._chain,\n            promise : this._promise.fail(...args),\n        });\n    }\n\n    fin(...args) {\n        args[0] = this._linkSpan('fin', false, true, args[0]);\n        return new TracedKew({\n            chain   : this._chain,\n            promise : this._promise.fin(...args),\n        });\n    }\n\n    tracedFin(...args) {\n        args[0] = this._linkSpan('fin', false, true, args[0]);\n        return new TracedKew({\n            chain   : this._chain,\n            promise : this._promise.fin(...args),\n        });\n    }\n\n    makeNodeResolver() {\n        return (err, data) => {\n            if (err) {\n                this.reject(err);\n            } else {\n                this.resolve(data);\n            }\n        };\n    }\n\n    spread(...args) {\n        args[0] = this._linkSpan('spread', false, false, args[0]);\n        return new TracedKew({\n            chain   : this._chain,\n            promise : this._promise.spread(...args),\n        });\n    }\n\n    tracedSpread(...args) {\n        args[0] = this._linkSpan('spread', true, false, args[0]);\n        return new TracedKew({\n            chain   : this._chain,\n            promise : this._promise.spread(...args),\n        });\n    }\n\n    resolve(...args) {\n        if (this._chain) {\n            this._chain.span.finish();\n        }\n        return this._promise.resolve(...args);\n    }\n\n    reject(...args) {\n        if (this._chain) {\n            this._setSpanError(this._chain.span, arguments);\n            this._chain.span.finish();\n        }\n        return this._promise.reject(...args);\n    }\n\n    then(...args) {\n        args[0] = this._linkSpan('then', false, false, args[0]);\n        return new TracedKew({\n            chain   : this._chain,\n            promise : this._promise.then(...args),\n        });\n    }\n\n    tracedThen(...args) {\n        // Modify the callback that gets invoked\n        args[0] = this._linkSpan('tracedThen', true, false, args[0]);\n        return new TracedKew({\n            chain   : this._chain,\n            promise : this._promise.then(...args),\n        });\n    }\n\n    //------------------------------------------------------------------------//\n    // Instance methods (TracedKew)\n    //------------------------------------------------------------------------//\n\n    finish(cb) {\n        this._promise.fin(() => {\n            let span = this.span();\n            if (span) {\n                span.finish();\n            }\n            if (cb) {\n                cb(span);\n            }\n        });\n        return this;\n    }\n\n    /**\n     * Allows the span associated with the promise to be named after the\n     * promise has started. This will be a safe no-op for promises that do not\n     * have an associated span.\n     *\n     * @param  {string} name\n     * @return {[type]}      [description]\n     */\n    name(name) {\n        let span = this.span();\n        if (span) {\n            span.setOperationName(name);\n        }\n        return this;\n    }\n\n    /**\n     * Returns the span associated with the promise, or null if there is no\n     * span.\n     *\n     * @return {Span}\n     */\n    span() {\n        return this._chain ? this._chain.span : null;\n    }\n\n    //------------------------------------------------------------------------//\n    // Protected methods\n    //------------------------------------------------------------------------//\n\n    /**\n     * Creates a new \"link\" in the conceptual chain of Promises. For example,\n     * the *invocation* of each callback in the chained functions would\n     * result in a new span being linked: each invocation gets its own span\n     * with the next invocation following from the prior.\n     *\n     * Q.all([ promise1, promise2 ])\n     *    .then(() => { doSomething(); })\n     *    .then(() => { doSomethingElse(); })\n     *\n     */\n    _linkSpan(name, traced, errFlag, f) {\n        // The callback's \"this\" needs to be retained, but the TracedKew \"this\"\n        // object also needs to be referened.\n        const self = this;\n\n        return function () {\n            // To allow incremental addition of traced promises to promise based\n            // code, account for both cases of there being a preceding span or\n            // not.\n            let nextSpan;\n            if (self._chain) {\n                const currentSpan = self.span();\n                const nextName = `${currentSpan.imp().getOperationName()}.${name}`;\n                // TODO: should technically be followsFrom, not childOf\n                nextSpan = Tracer.startSpan(nextName, { childOf : currentSpan });\n                _joinSpans(currentSpan, nextSpan);\n                if (errFlag) {\n                    self._setSpanError(currentSpan, arguments);\n                }\n                currentSpan.finish();\n                self._chain.span = nextSpan;\n            } else {\n                nextSpan = Tracer.startSpan(name);\n                self._chain = new SpanChain(nextSpan);\n            }\n\n            // Invoke the callback\n            let args = arguments;\n            if (traced) {\n                args = [ nextSpan ].concat(Array.prototype.slice.call(arguments));\n            }\n\n            // NOTE: the \"this\" and \"self\" are different objects\n            return _wrap(self, f.apply(this, args));\n        };\n    }\n\n    _setSpanError(span, args) {\n        span.setTag('error', 'true');\n\n        if (!args || args.length === 0) {\n            return;\n        }\n\n        // Normalize in case it is an Arguments object\n        args = Array.prototype.slice.call(args);\n\n        let details = new Array(args.length);\n        let message = '';\n        for (let i = 0; i < args.length; i++) {\n            if (args[i] instanceof Error) {\n                details[i] = {\n                    type : 'Error',\n                };\n                if (args[i].message) {\n                    details[i].message = args[i].message;\n                }\n                if (args[i].fileName) {\n                    details[i].fileName = args[i].fileName;\n                }\n                if (args[i].stack) {\n                    details[i].stack = args[i].stack.split('\\n');\n                }\n                if (i === 0) {\n                    message = args[i].message || 'Error object';\n                }\n            } else {\n                details[i] = args[i];\n                if (i === 0) {\n                    message = `${args[i]}`;\n                }\n            }\n        }\n        span.logEvent(`error: ${message}`, { details : details });\n    }\n}\n"]}