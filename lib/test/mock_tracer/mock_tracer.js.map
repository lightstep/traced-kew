{"version":3,"sources":["../../../src/test/mock_tracer/mock_tracer.js"],"names":[],"mappings":";;;;;;;;AAAA;;;;AACA;;;;;;;;AAEA;;;;IAIqB,U;;;;;AAEjB;AACA;AACA;;qCAEa,M,EAAQ;AACjB,iBAAK,gBAAL,GAAwB,MAAxB;AACH;;;kCAES,M,EAAQ;AACd;AACA;AACA;AACA,gBAAM,OAAO,KAAK,UAAL,CAAgB,MAAhB,CAAb;;AAEA,iBAAK,gBAAL,CAAsB,OAAO,aAA7B;AACA,iBAAK,MAAL,CAAY,IAAZ,CAAiB,IAAjB;;AAEA,gBAAI,OAAO,UAAX,EAAuB;AACnB,qBAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,OAAO,UAA3B,EAAuC,GAAvC,EAA4C;AACxC,yBAAK,YAAL,CAAkB,OAAO,UAAP,CAAkB,CAAlB,CAAlB;AACH;AACJ;;AAED;AACA,iBAAK,WAAL,GAAmB,IAAI,KAAJ,GAAY,KAA/B;;AAEA,mBAAO,IAAP;AACH;;;+BAEM,I,EAAM,M,EAAQ,O,EAAS;AAC1B,kBAAM,IAAI,KAAJ,CAAU,qBAAV,CAAN;AACH;;;gCAEO,M,EAAQ,O,EAAS;AACrB,kBAAM,IAAI,KAAJ,CAAU,qBAAV,CAAN;AACH;;;8BAEK,Q,EAAU;AACZ,iBAAK,KAAL;AACA,gBAAI,QAAJ,EAAc;AACV,yBAAS,IAAT;AACH;AACJ;;AAED;AACA;AACA;;;;AAEA,0BAAc;AAAA;;AACV,aAAK,gBAAL,GAAwB,IAAxB;AACA,aAAK,MAAL,GAAc,EAAd;AACH;;;;qCAEY;AACT,mBAAO,wBAAa,IAAb,CAAP;AACH;;AAED;;;;;;gCAGQ;AACJ,iBAAK,MAAL,GAAc,EAAd;AACH;;AAED;;;;;;;iCAIS;AACL,mBAAO,qBAAW,KAAK,MAAhB,CAAP;AACH;;;;;;kBAxEgB,U","file":"mock_tracer.js","sourcesContent":["import MockSpan from './mock_span';\nimport Report from './report';\n\n/**\n * OpenTracing Tracer implementation designed for use in\n * unit tests.\n */\nexport default class MockTracer {\n\n    //------------------------------------------------------------------------//\n    // OpenTracing API\n    //------------------------------------------------------------------------//\n\n    setInterface(tracer) {\n        this._tracerInterface = tracer;\n    }\n\n    startSpan(fields) {\n        // _allocSpan is given it's own method so that derived classes can\n        // allocate any type of object they want, but not have to duplicate\n        // the other common logic in startSpan().\n        const span = this._allocSpan(fields);\n\n        span.setOperationName(fields.operationName);\n        this._spans.push(span);\n\n        if (fields.references) {\n            for (let i = 0; i < fields.references; i++) {\n                span.addReference(fields.references[i]);\n            }\n        }\n\n        // Capture the stack at the time the span started\n        span._startStack = new Error().stack;\n\n        return span;\n    }\n\n    inject(span, format, carrier) {\n        throw new Error('NOT YET IMPLEMENTED');\n    }\n\n    extract(format, carrier) {\n        throw new Error('NOT YET IMPLEMENTED');\n    }\n\n    flush(callback) {\n        this.clear();\n        if (callback) {\n            callback(null);\n        }\n    }\n\n    //------------------------------------------------------------------------//\n    // MockTracer-specific\n    //------------------------------------------------------------------------//\n\n    constructor() {\n        this._tracerInterface = null;\n        this._spans = [];\n    }\n\n    _allocSpan() {\n        return new MockSpan(this);\n    }\n\n    /**\n     * Discard any buffered data.\n     */\n    clear() {\n        this._spans = [];\n    }\n\n    /**\n     * Return the buffered data in a format convenient for making unit test\n     * assertions.\n     */\n    report() {\n        return new Report(this._spans);\n    }\n}\n"]}