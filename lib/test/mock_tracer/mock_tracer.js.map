{"version":3,"sources":["../../../src/test/mock_tracer/mock_tracer.js"],"names":[],"mappings":";;;;;;;;AAAA;;;;;;;;AAEA;;;;IAIqB,U;;;;;AAEjB;AACA;AACA;;qCAEa,M,EAAQ;AACjB,iBAAK,gBAAL,GAAwB,MAAxB;AACH;;;kCAES,M,EAAQ;AACd;AACA;AACA;AACA,gBAAM,OAAO,KAAK,UAAL,CAAgB,MAAhB,CAAb;;AAEA,iBAAK,gBAAL,CAAsB,OAAO,aAA7B;AACA,iBAAK,YAAL,CAAkB,KAAK,IAAL,EAAlB,IAAiC,IAAjC;;AAEA,gBAAI,OAAO,UAAX,EAAuB;AACnB,qBAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,OAAO,UAA3B,EAAuC,GAAvC,EAA4C;AACxC,yBAAK,YAAL,CAAkB,OAAO,UAAP,CAAkB,CAAlB,CAAlB;AACH;AACJ;;AAED,mBAAO,IAAP;AACH;;;+BAEM,I,EAAM,M,EAAQ,O,EAAS;AAC1B,kBAAM,IAAI,KAAJ,CAAU,qBAAV,CAAN;AACH;;;gCAEO,M,EAAQ,O,EAAS;AACrB,kBAAM,IAAI,KAAJ,CAAU,qBAAV,CAAN;AACH;;;8BAEK,Q,EAAU;AACZ,gBAAM,OAAO,OAAO,IAAP,CAAY,KAAK,YAAjB,CAAb;AACA,gBAAM,QAAQ,IAAI,KAAJ,CAAU,KAAK,MAAf,CAAd;AACA,iBAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,KAAK,MAAzB,EAAiC,GAAjC,EAAsC;AAClC,sBAAM,CAAN,IAAW,KAAK,YAAL,CAAkB,KAAK,CAAL,CAAlB,CAAX;AACH;AACD,iBAAK,YAAL,GAAoB,EAApB;;AAEA;AACA;AACA;AACA;AACA,iBAAK,QAAL,CAAc,KAAd;;AAEA,gBAAI,QAAJ,EAAc;AACV,mBAAG,IAAH;AACH;AACJ;;AAED;AACA;AACA;;;;AAEA,8BAAuB;AAAA,YAAT,KAAS,QAAT,KAAS;;AAAA;;AACnB,aAAK,gBAAL,GAAwB,IAAxB;;AAEA,aAAK,YAAL,GAAoB,EAApB;AACA,aAAK,QAAL,GAAgB,SAAS,YAAY,CAAE,CAAvC;AACH;;;;qCAEY;AACT,mBAAO,IAAI,QAAJ,CAAa,IAAb,CAAP;AACH;;;;;;kBApEgB,U","file":"mock_tracer.js","sourcesContent":["import opentracing from 'opentracing';\n\n/**\n * OpenTracing Tracer implementation designed for use in\n * unit tests.\n */\nexport default class MockTracer {\n\n    //------------------------------------------------------------------------//\n    // OpenTracing API\n    //------------------------------------------------------------------------//\n\n    setInterface(tracer) {\n        this._tracerInterface = tracer;\n    }\n\n    startSpan(fields) {\n        // _allocSpan is given it's own method so that derived classes can\n        // allocate any type of object they want, but not have to duplicate\n        // the other common logic in startSpan().\n        const span = this._allocSpan(fields);\n\n        span.setOperationName(fields.operationName);\n        this._spansByUUID[span.uuid()] = span;\n\n        if (fields.references) {\n            for (let i = 0; i < fields.references; i++) {\n                span.addReference(fields.references[i]);\n            }\n        }\n\n        return span;\n    }\n\n    inject(span, format, carrier) {\n        throw new Error('NOT YET IMPLEMENTED');\n    }\n\n    extract(format, carrier) {\n        throw new Error('NOT YET IMPLEMENTED');\n    }\n\n    flush(callback) {\n        const keys = Object.keys(this._spansByUUID);\n        const spans = new Array(keys.length);\n        for (let i = 0; i < keys.length; i++) {\n            spans[i] = this._spansByUUID[keys[i]];\n        }\n        this._spansByUUID = {};\n\n        // The _flushCb is a MockTracer specific hook to get the collected\n        // data. The callback passed into the function is the OpenTracing API\n        // callback which simply signifies when the flush has completed (and\n        // whether there was an error or not).\n        this._flushCb(spans);\n\n        if (callback) {\n            cb(null);\n        }\n    }\n\n    //------------------------------------------------------------------------//\n    // MockTracer-specific\n    //------------------------------------------------------------------------//\n\n    constructor({ flush }) {\n        this._tracerInterface = null;\n\n        this._spansByUUID = {};\n        this._flushCb = flush || function () {};\n    }\n\n    _allocSpan() {\n        return new MockSpan(this);\n    }\n}\n"]}